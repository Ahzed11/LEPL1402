accessible: true
author: Bastin J. , Piron H.
categories:
- module6
context: |-
    For this task you will learn to make some asynchronous calculation using Future_, ExecutorService_ and Callable_.
    You will implement two methods of the class AsyncTask_ : ``indexOf`` and ``createFutures``.

    .. code-block:: java

        import java.util.ArrayList;
        import java.util.List;
        import java.util.concurrent.Callable;
        import java.util.concurrent.ExecutionException;
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;
        import java.util.concurrent.Future;

        public class AsyncTask {

            private static ExecutorService executor = Executors.newFixedThreadPool(10);

            /**
             * Return a Future that return the first index of elem inside longArray or -1.
             * longArray is a non ordered random array.
             * You have to use executor to success this task. Don't hesite to read the
             * documentation of Future and ExecutorService in order to understand what
             * you are supposed to do.
             */
            public static Future<Integer> indexOf(int[] longArray, int elem){
                //TODO
            }

            /**
             * Do some usefull calculation
             */
            public static Integer someCalculations(int[] longArray, int i){
                //HIDDEN to you
            }

            /**
             * Once all thread are finished, do another very usefull calculation.
             */
            public static void someOtherCalculations(List<Integer> results, Integer calculated){
                //HIDDEN TO YOU
            }

            /**
             * Return a list of Future that try to find the index of all elements
             * inside array.
             * Each Future must run in a new thread
             */
            public static List<Future<Integer>> createFutures(int[] array, int[] elements){
                //TODO
            }

            /**
             * This code must work thanks to your implementation of the to functions above.
             */
            public static void test(int[] array, int[] elements, int randomNumber){
                //get the list of all futures that runs inside different threads
                List<Future<Integer>> futures = createFutures(array, elements);
                //while the threads are executing asynchronously, we can perform
                //some usefull tasks
                Integer calc = someCalculations(array, randomNumber);

                //Then we need the result of the threads
                List<Integer> res = new ArrayList<>(futures.size());
                try {
                    for(int i = 0; i< futures.size(); i++){
                        res.add(futures.get(i).get());
                    }
                } catch(InterruptedException e){

                } catch(ExecutionException e){

                }

                //finally we perform other calculation with the results of the threads
                //and the other calculation we made
                SomeOtherCalculations(res, calc);

            }

        }

    .. _Future: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html
    .. _ExecutorService: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html
    .. _Callable: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html
    .. _AsyncTask: /course/LEPL1402/Future/AsyncTask.java
environment: pyjavacpp
evaluate: best
file: ''
groups: false
input_random: '0'
limits:
    memory: '100'
    time: '30'
    output: '2'
name: Future
network_grading: false
problems:
    student_indexOf:
        default: ''
        header: 'Paste here the **body** of the method ``indexOf`` :'
        name: ''
        language: java
        type: code
    student_createFutures:
        default: ''
        name: ''
        type: code
        header: 'Paste here the **body** of the method ``createFutures`` :'
        language: java
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
weight: 1.0
